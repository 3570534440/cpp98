/*
										   写下前面
	以下内容来自c++ prime plus（第六版）

	虽然结构化编程的理念提高了程序的清晰度、可靠性，并使之便于维护，但它在编写大型程序时，仍面临着挑战。
为应付这种挑战，OOP提供了一种新方法。与强调算法的过程性编程不同的是，OOP强调的是数据。OOP不像过程性
编程那样，试图使问题满足语言的过程性方法，而是试图让语言来满足问题的要求。其理念是设计与问题的本质
特性相对应的数据格式。
	在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。例如，类可
以描述公司管理人员的基本特征（姓名、头衔、工资、特长等），而对象则代表特定的管理人员（Guilford Sheepblat、
副总裁、$925 000、知道如何恢复Windows注册表）。通常，类规定了可使用哪些数据来表示对象以及可以对这些数
据执行哪些操作。例如，假设正在开发一个能够绘制矩形的计算机绘图程序，则可以定义一个描述矩形的类。定义
的数据部分应包括顶点的位置、长和宽、4条边的颜色和样式、矩形内部的填充颜色和图案等；定义的操作部分可以
包括移动、改变大小、旋转、改变颜色和图案、将矩形复制到另一个位置上等操作。这样，当使用该程序来绘制矩
形时，它将根据类定义创建一个对象。该对象保存了描述矩形的所有数据值，因此可以使用类方法来修改该矩形。
如果绘制两个矩形，程序将创建两个对象，每个矩形对应一个。
	OOP程序设计方法首先设计类，它们准确地表示了程序要处理的东西。例如，绘图程序可能定义表示矩形、直
线、圆、画刷、画笔的类。类定义描述了对每个类可执行的操作，如移动圆或旋转直线。然后您便可以设计
一个使用这些类的对象的程序。从低级组织（如类）到高级组织（如程序）的处理过程叫做自下向上（bottom-up）
的编程。
	OOP编程并不仅仅是将数据和方法合并为类定义。例如，OOP还有助于创建可重用的代码，这将减少大量的工作。
信息隐藏可以保护数据，使其免遭不适当的访问。多态让您能够为运算符和函数创建多个定义，通过编程上下文
来确定使用哪个定义。继承让您能够使用旧类派生出新类。正如接下来将看到的那样，OOP引入了很多新的理念，
使用的编程方法不同于过程性编程。它不是将重点放在任务上，而是放在表示概念上。有时不一定使用自上向下
的编程方法，而是使用自下向上的编程方法。本书将通过大量易于掌握的示例帮助读者理解这些要点。
设计有用、可靠的类是一项艰巨的任务，幸运的是，OOP语言使程序员在编程中能够轻松地使用已有的类。厂商
提供了大量有用的类库，包括设计用于简化Windows或Macintosh环境下编程的类库。C++真正的优点之一是：可以
方便地重用和修改现有的、经过仔细测试的代码。
	
	泛型编程（generic programming）是C++支持的另一种编程模式。它与OOP的目标相同，即使重用代码和抽象通
用概念的技术更简单。不过OOP强调的是编程的数据方面，而泛型编程强调的是独立于特定数据类型。它们的侧重点
不同。OOP是一个管理大型项目的工具，而泛型编程提供了执行常见任务（如对数据排序或合并链表）的工具。术语
泛型（generic）指的是创建独立于类型的代码。C++的数据表示有多种类型——整数、小数、字符、字符串、用户定
义的、由多种类型组成的复合结构。例如，要对不同类型的数据进行排序，通常必须为每种类型创建一个排序函数。
泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。
C++模板提供了完成这种任务的机制。

*/


#include <iostream>
#include <string>

class Animal//定义一个类，，通常第一个字母是大写，用class来声明
{
public:
	std::string mouth;

	void eat();
	void sleep();
	void drool();
};

class Pig : public Animal//后面的继承前面的 
{
public:
	void climb();
};

class Turtle : public Animal
{
public:
	void swim();
};

void Animal::eat()
{
	std::cout << "I'm eatting!" << std::endl;
}

void Animal::sleep()



{
	std::cout << "I'm sleeping!Don't disturb me!" << std::endl;
}

void Animal::drool()
{
	std::cout << "我是公的，看到母的我会流口水，我正在流口水。。。" << std::endl;
}

void Pig::climb()
{
	std::cout << "我是一个只漂亮的小母猪猪，我会上树，我正在爬树，嘘。。。" << std::endl;
}

void Turtle::swim()
{
	std::cout << "我是一只小甲鱼，当母猪想抓我的时候，我就游到海里。。哈哈。。" << std::endl;
}

int main()
{
	Pig pig;
	Turtle turtle;

	pig.eat();
	turtle.eat();
	pig.climb();
	turtle.swim();

	return 0;
}